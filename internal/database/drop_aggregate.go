package database

import (
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
)

// Represents a single target associated with a drop
type TargetInfo struct {
	Type string `json:"type"`
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

// Represents a drop with its associated targets
type DropWithTargets struct {
	ID         uuid.UUID `json:"id"`
	UserID     uuid.UUID `json:"user_id"`
	Title      string    `json:"title"`
	Content    string    `json:"content"`
	PostDate   time.Time `json:"post_date"`
	ExpireDate time.Time `json:"expire_date"`
	// Maybe UserEmail string `json:"user_email,omitempty"` // At some point
	// Add edited_by at some point
	Targets []TargetInfo `json:"targets"`
}

// AggregateDropRows processes the flat rows from sqlc queries into a nested structure.
// Ensure the input 'rows' slice matches the actual sqlc generated type (e.g., []GetActiveDropsWithTargetsRow)
// Ensure the field names (row.TargetID, row.TargetType, row.TargetName) match the sqlc struct.
func AggregateDropRows(rows []GetActiveDropsWithTargetsRow) []DropWithTargets {
	dropsMap := make(map[uuid.UUID]*DropWithTargets)
	orderedDropIDs := make([]uuid.UUID, 0)

	for _, row := range rows {
		drop, exists := dropsMap[row.DropID]
		if !exists {
			// First time seeing this drop, create the main structure
			drop = &DropWithTargets{
				ID:         row.DropID,
				UserID:     row.DropUserID,
				Title:      row.DropTitle,
				Content:    row.DropContent,
				PostDate:   row.DropPostDate,
				ExpireDate: row.DropExpireDate,
				Targets:    make([]TargetInfo, 0), // Initialize empty slice
			}
			dropsMap[row.DropID] = drop
			orderedDropIDs = append(orderedDropIDs, row.DropID) // Record the order
		}

		// Add the target info if TargetType is valid (not NULL from LEFT JOIN)
		// --- Adjust based on actual Nullable Type generated by sqlc for TargetType ---
		var targetTypeStr string
		if row.TargetType.Valid { // Example check for sqlc custom type or sql.NullString
			targetTypeStr = string(row.TargetType.TargetType) // Adjust conversion based on actual type
		} else {
			// If TargetType itself is NULL, we likely skip adding any target info for this row
			continue
		}
		// ---

		var targetID int32
		// Handle nullable TargetID (Use Int64 or Int32 based on sqlc generated type)
		if row.TargetID.Valid {
			targetID = row.TargetID.Int32
		} else {
			// Target ID is NULL. This might be valid for type 'General'.
			// Assign 0, assuming 0 is not a real target ID. Adjust if needed.
			if targetTypeStr == "General" {
				targetID = 0
			} else {
				// If ID is NULL for a non-General type, maybe log a warning or skip?
				log.Printf("Warning: Target type '%s' has NULL ID for drop %s. Assigning ID 0.", targetTypeStr, row.DropID)
				targetID = 0 // Or 'continue' to skip this target entirely
			}
		}

		targetName := row.TargetName
		if targetName == "General" && targetTypeStr != "General" {
			targetName = fmt.Sprintf("%s %d", targetTypeStr, targetID)
		}

		target := TargetInfo{
			Type: targetTypeStr,
			ID:   targetID,
			Name: targetName,
		}
		drop.Targets = append(drop.Targets, target)
	}

	// Build the final slice in the original order
	result := make([]DropWithTargets, len(orderedDropIDs))
	for i, dropID := range orderedDropIDs {
		result[i] = *dropsMap[dropID] // Dereference the pointer
	}
	return result
}

// Duplicate function to handle the rows produced by the current user qery
func AggregateCurrentUserDropRows(rows []GetDropsForUserWithTargetsRow) []DropWithTargets {
	dropsMap := make(map[uuid.UUID]*DropWithTargets)
	orderedDropIDs := make([]uuid.UUID, 0)

	for _, row := range rows {
		drop, exists := dropsMap[row.DropID]
		if !exists {
			// First time seeing this drop, create the main structure
			drop = &DropWithTargets{
				ID:         row.DropID,
				UserID:     row.DropUserID,
				Title:      row.DropTitle,
				Content:    row.DropContent,
				PostDate:   row.DropPostDate,
				ExpireDate: row.DropExpireDate,
				Targets:    make([]TargetInfo, 0), // Initialize empty slice
			}
			dropsMap[row.DropID] = drop
			orderedDropIDs = append(orderedDropIDs, row.DropID) // Record the order
		}

		targetTypeStr := string(row.TargetType)

		var targetID int32
		// Handle nullable TargetID (Use Int64 or Int32 based on sqlc generated type)
		if row.TargetID.Valid {
			targetID = row.TargetID.Int32
		} else {
			// Target ID is NULL. This might be valid for type 'General'.
			// Assign 0, assuming 0 is not a real target ID. Adjust if needed.
			if targetTypeStr == "General" {
				targetID = 0
			} else {
				// If ID is NULL for a non-General type, maybe log a warning or skip?
				log.Printf("Warning: Target type '%s' has NULL ID for drop %s. Assigning ID 0.", targetTypeStr, row.DropID)
				targetID = 0 // Or 'continue' to skip this target entirely
			}
		}

		targetName := row.TargetName
		if targetName == "General" && targetTypeStr != "General" {
			targetName = fmt.Sprintf("%s %d", targetTypeStr, targetID)
		}

		target := TargetInfo{
			Type: targetTypeStr,
			ID:   targetID,
			Name: targetName,
		}
		drop.Targets = append(drop.Targets, target)
	}

	// Build the final slice in the original order
	result := make([]DropWithTargets, len(orderedDropIDs))
	for i, dropID := range orderedDropIDs {
		result[i] = *dropsMap[dropID] // Dereference the pointer
	}
	return result
}

func AggregateDropAndTargetRows(rows []GetDropWithTargetsByIDRow) []DropWithTargets {
	if len(rows) == 0 {
		return []DropWithTargets{}
	}

	firstRow := rows[0]
	finalDrop := DropWithTargets{
		ID:		firstRow.DropID,
        UserID:     firstRow.DropUserID,
        Title:      firstRow.DropTitle,
        Content:    firstRow.DropContent,
        PostDate:   firstRow.DropPostDate,
        ExpireDate: firstRow.DropExpireDate,
		//other fields at some point (edited_by)
		Targets:    make([]TargetInfo, 0),
	}
	// here handle NullUUID if needed

	for _, row := range rows {
		if row.TargetType.Valid {
			targetTypeStr := string(row.TargetType.TargetType)

			var targetID int32
			if row.TargetID.Valid {
				targetID = row.TargetID.Int32
			} else {
				if targetTypeStr == "General" {
					targetID = 0
				} else {
					log.Printf("Warning: Target type '%s' has NULL ID for drop '%s'. Assigning ID 0.", targetTypeStr, row.DropID)
					targetID = 0
				}
			}

			targetName := row.TargetName

			target := TargetInfo{
				Type: targetTypeStr,
				ID:	targetID,
				Name: targetName,
			}
			finalDrop.Targets = append(finalDrop.Targets, target)
		}
	}

	return []DropWithTargets{finalDrop}

}